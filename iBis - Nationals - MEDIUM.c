#pragma config(Sensor, S1,     frontIR,        sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     backIR,         sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          frontLeft,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          backLeft,      tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorC,          backRight,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          frontRight,    tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//
//Motor and sensor configuration

// abs is the distance from 0 a number is

//Bringing values and variables from the hitechnic IR sensor program to this program.
#include "hitechnic-irseeker-v2.h"

#define SHORTSTR 150 // ShortStrength (if the ball is close) equal to 140(100)
#define FARSTR 30 // FarStrength (if the ball is far) equal to 40(10)
#define MINSTR 10 // 10
#define MOVESPEED 100//100

/* Initialising the global variables*/
int target; // Heading of the goal given by the compass sensor
int frontDir; // Directions given by frontIR Sensor
int backDir; // Directions given by backIR Sensor
int backStr; // Strength reading given by backIR Sensor
int frontStr; // Strength reading given by frontIR Sensor
int current; // Current heading of the robot given by the compass sensor


float max (float a, float b); // Function for calculating maximum motor value
float min (float a, float b); // Function for calculating minimum motor value (NOT USED)
float constrain (float min, float max, float value); // Function for constraining values (e.g. 0-1)

void move(float angle, float speed, float rotation); // Function for the movement of the robot
int angle(int frontDir, int backDir, int frontStr, int backStr); // Function for the angle of the ball
float multi (int x); // Function for calculating the multiplier for movement

int sign (int x); // Function for giving sign a value dependent on the ballAngle

task main() // Start of code
{
	setLEDColor(ledRed); //Robot's light colour set to red

	/*Setting up a struct to hold data for the sensor.*/
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;


	/*Initialising the IR sensors.*/
	initSensor(&irSeeker1, frontIR);
	initSensor(&irSeeker2, backIR);

	target = 2 * SensorValue[compass]; // Heading of goal is equal to compass value * 2 (0-360)


	waitForButtonPress();// Waiting for any button to be pressed
	setLEDColor(ledGreen); // Sets robot colour to green

	while(true) //Starting forever loop.
	{
		/*This is asking for a reading from the sensors.*/
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);

		/*This is getting the data from the IR sensors and putting
		the different values to different variables.*/
		frontDir = irSeeker1.acDirection;
		backDir = irSeeker2.acDirection;
		frontStr = irSeeker1.enhStrength;
		backStr = irSeeker2.enhStrength;

		current = 2 * SensorValue(compass); // Current heading of robot is equal to compass value * 2 (0-360)

		int ballAngle = angle(frontDir, backDir, frontStr, backStr); // Variable ballAngle is using function angle

		int ballStrength = max(frontStr, backStr);// ballStrength is equal to fStr if fStr is larger & vice versa

		int moveAngle = 0; // moveAngle reset to 0

		displayTextLine (5, "%d", ballAngle); // Displays the variable ballAngle on the EV3 screen
		displayTextLine (6, "%d, %d", frontStr, backStr); // Displays the variable frontStr and backStr on the EV3 screen
		displayTextLine(7, "%d, %d, %d, %d, %d", irSeeker1.acValues[0], irSeeker1.acValues[1], irSeeker1.acValues[2], irSeeker1.acValues[3],irSeeker1.acValues[4]);

		int moveSpeed = MOVESPEED;
		if (ballStrength < MINSTR)
		{

			moveSpeed = 0;
		}
		else
		{

		/* This section controls how the robot should move dependent on the strength and direction of the ball */

			if (abs(ballAngle) < 30) // If the angle of the ball is less than 30
			{
				moveAngle = ballAngle * 0.7; // Go towards the ball (with tightener)
			}
			else if (abs(ballAngle) < 60) // If the angle of the ball is between 20 and 60
			{
				moveAngle = ballAngle + multi(ballStrength) * (45 * sign(ballAngle));
			}
			else // If the angle of the ball is greater than 60
			{
				moveAngle = ballAngle + multi(ballStrength) * (90 * sign(ballAngle));
			}
		}

		/* This function works out the compass correction using the inital (goal) and current values*/
		int rotation;
		rotation = target - current;
		rotation *= 1.5; // Compass multiplier

		/* This section sets the direction the robot needs to face in a range of -180 to 180.*/
		if (rotation > 180)
		{
			rotation -= 360;
		}
		else if(rotation <= -180)
		{
			rotation += 360;
		}


		move(moveAngle, moveSpeed , -rotation); // Starting function move
		displayTextLine (8, "%d", rotation); // Displays the variable rotation on the EV3 screen
		displayTextLine (8, "%d", rotation); // Displays the variable rotation on the EV3 screen
	}
}

//Checks which of the two motor values is higher.
float max (float a, float b)
{ if (a > b) // If a is greater than b
	{
		return a; // Return a
	}
	else // If b is greater than a
	{
		return b; // Return b
	}
}

// Checks which of the two values is lower
float min (float a, float b)
{
	if (a < b) // If a is less than b
	{
		return a; // Return a
	}
	else // If b is less than a
	{
		return b; // Return b
	}
}

/* This function "brackets" (or constrains) the values so that it is not greater than the range*/
float constrain (float min, float max, float value)
{
	if (value > max)
	{
		return max;
	}
	if (value < min)
	{
		return min;
	}
	else
	{
		return value;
	}
}


void move(float angle, float speed, float rotation)// Intialising the function move with the paramaters angle, speed and rotation
{

	angle = 45 - angle;
	float a = cosDegrees(angle); // a is equal to the angle required (cos)
	float b = sinDegrees(angle);// b is equal to the angle required (sin)
	float fLeftspeed = -a; // Motor frontLeft's speed is set to -a
	float bRightspeed = a; // Motor backRight's speed is set to a
	float fRightspeed = b; // Motor frontRight's speed is set to b
	float bLeftspeed = -b; // Motor backLeft's speed is set to -b

	// Finding the absolute maximum speed (decimal value) of the motors
	float maxSpeed = max(fabs(fLeftspeed), fabs(bRightspeed));
	maxSpeed = max(fabs(maxSpeed), fabs(fRightspeed));
	maxSpeed = max(fabs(maxSpeed), fabs(bLeftspeed));


	maxSpeed = maxSpeed != 0 ? speed / maxSpeed : 0; // When maxSpeed is not equal to 0, it is equal to speed/maxSpeed

	/* This section finds the motor values for each of the motors dependent on the ball position and the compass correction*/
	fLeftspeed = fLeftspeed * maxSpeed + rotation;
	bRightspeed = bRightspeed * maxSpeed + rotation;
	fRightspeed = fRightspeed * maxSpeed + rotation;
	bLeftspeed = bLeftspeed * maxSpeed + rotation;

	// Finding the absolute max speed of the motors
	maxSpeed = max(abs(fLeftspeed), abs(bRightspeed));
	maxSpeed = max (abs(maxSpeed), abs(fRightspeed));
	maxSpeed = max (abs(maxSpeed), abs(bLeftspeed));


	if (maxSpeed > 100) //If the maximum is greater than 100 it reduces the motor values in proportion
	{
		fLeftspeed = fLeftspeed / maxSpeed * 100;
		bRightspeed = bRightspeed / maxSpeed * 100;
		fRightspeed = fRightspeed / maxSpeed * 100;
		bLeftspeed = bLeftspeed / maxSpeed * 100;
	}

	/* Gives each of the motors a speed value using the calculations above*/
	motor[frontLeft] = fLeftspeed;
	motor[backRight] = bRightspeed;
	motor[frontRight] = fRightspeed;
	motor[backLeft] = bLeftspeed;

}

/* This function assigns sign a value dependent on the ballAngle*/
int sign (int x)
{
	if (x > 0) // If x is greater than 0
	{
		return 1; // Sign is equal to 1
	}
	else if (x < 0) // If x is less than 0
	{
		return -1; // Sign is equal -1
	}
	else // If x is equal to 0
	{
		return 0; // Sign is equal to 0
	}
}

/* This function substitutes each direction that the IR provides for an Angle*/
int angle(int frontDir, int backDir, int frontStr, int backStr)
{
	int returnAngle = 0;
	if (frontStr > backStr)
	{
		returnAngle = (frontDir-5)*(180/7);
	}
	else
	{
		returnAngle = -(180 - (backDir-5)*(180/7));
	}
	/* Sets the angle of the ball in a range of -180 to 180*/
	if (returnAngle > 180)
	{
		returnAngle -= 360;
	}
	else if (returnAngle < -180)
	{
		returnAngle += 360;
	}

	return returnAngle;
}

/* This function calculates a multiplier for movement*/
float multi (int x) // x is ballStrength
{
	float value = (float)(x - FARSTR) / (float)(SHORTSTR - FARSTR);

	return constrain(0, 1, value); // Range of 0-1

}
